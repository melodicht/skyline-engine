#pragma once

// SKL_SLOW
// 0 - No slow code allowed
// 1 - Slow code allowed

// SKL_INTERNAL
// 0 - For release
// 1 - Not for release

// Project Fixed Width Numerical Types
#include <stdint.h>
#include <cstddef>

typedef uint8_t  u8;
typedef uint8_t  u08;
typedef uint16_t u16;
typedef uint32_t u32;
typedef uint64_t u64;

typedef int8_t   s8;
typedef int8_t   s08;
typedef int16_t  s16;
typedef int32_t  s32;
typedef int64_t  s64;

typedef float    f32;
typedef double   f64;

typedef bool     b8;
typedef u32      b32;
// If this fails this means you have to substitute b8 on a different type on your system
static_assert(sizeof(b8) == 1);

typedef size_t   siz;

// Project Keywords
#define file_global static
#define local static
#define local_persist static

// Platform definitions
#if (defined(__APPLE__) && defined(__MACH__))
    #define PLATFORM_APPLE
#endif

#if defined(__unix__) || defined(__unix) || defined(unix) ||    \
    (defined(PLATFORM_APPLE))
    #define PLATFORM_UNIX
#endif 

#if defined(_WIN32) || defined(_WIN64)
    #define PLATFORM_WINDOWS
#endif


// Logging
#if SKL_ENABLED_LOGGING

#include <iostream>
#include <cassert>

#define LOG(x) std::cout << x << std::endl
#define LOG_ERROR(x) std::cerr << x << std::endl

#else

#define LOG(x) (void)(0)
#define LOG_ERROR(x) (void)(0)

#endif

// Misc

// Assumes that the Expression evaluates to an array.
#define ArrayCount(Expression) (sizeof(Expression)/sizeof((Expression)[0]))

// Source - https://stackoverflow.com/a
// Posted by David Titarenco, modified by community. See post 'Timeline' for change history
// Retrieved 2026-01-22, License - CC BY-SA 4.0
#define Maximum(a,b)                            \
    ({ decltype(a) _a = (a);                 \
        decltype(b) _b = (b);                \
        _a > _b ? _a : _b; })

#define Minimum(a,b)                            \
    ({ decltype(a) _a = (a);                 \
        decltype(b) _b = (b);                \
        _a < _b ? _a : _b; })


#if SKL_SLOW

#if defined(_MSC_VER)
#define DEBUG_BREAK() __debugbreak()
#elif defined(__GNUC__) || defined(__clang__)
#define DEBUG_BREAK() __builtin_trap()
#else
#define DEBUG_BREAK() (*(volatile int*)0 = 0)
#endif

// Expressions are wrapped with do { }while(0); to prevent  
// if 
//  Macro()
// else
// From evaluating differently

// Breaks if expression is false, doesn't run at all in release build
#define ASSERT(Expression) do { if(!(Expression)) { DEBUG_BREAK(); }}while(0)
//Breaks if expression is false and prints message, doesn't run at all in release build
#define ASSERT_PRINT(Expression, Message) do{if(!(Expression)) { std::cerr << (Message, stderr) << std::endl; DEBUG_BREAK(); }}while(0)

// Breaks if expression is false, keeps just expression in release build
#define TRY(Expression) do{if (!(Expression)) { DEBUG_BREAK(); }}while(0)
// Breaks if expression has different value then expected, keeps just expression in release build
#define TRY_EXPECT(Expression, Expected) do{if ((Expression) != (Expected)) { DEBUG_BREAK(); }}while(0)

#else
#define ASSERT(Expression) ((void)0)
#define ASSERT_PRINT(Expression, Message) ((void)0)
#define TRY(Expression) ((void)(Expression))
#define TRY_EXPECT(Expression, Expected) ((void)(Expression))
#endif



#define Kilobytes(Expression) ((Expression)*1024LL)
#define Megabytes(Expression) (Kilobytes(Expression)*1024LL)
#define Gigabytes(Expression) (Megabytes(Expression)*1024LL)
#define Terabytes(Expression) (Gigabytes(Expression)*1024LL)

// Getting the CPU to pause, for thread-safe spin-wait loops.
// TODO(marvin): The below CPUPause is generated by Claude for cross-platformness, should verify that it works on multiple architectures.

#include <atomic>

#if defined(__x86_64__) || defined(_M_X64) || defined(__i386__) || defined(_M_IX86)
    #include <immintrin.h>  // For _mm_pause()
#endif

inline void CPUPause() {
#if defined(__x86_64__) || defined(_M_X64) || defined(__i386__) || defined(_M_IX86)
    _mm_pause();
#elif defined(__aarch64__) || defined(_M_ARM64)
    asm volatile("yield" ::: "memory");
#elif defined(__arm__) || defined(_M_ARM)
    #if defined(_MSC_VER)
        __yield();
    #else
        asm volatile("yield" ::: "memory");
    #endif
#elif defined(__riscv)
    asm volatile("pause");
#else
    // Fallback: standard C++ compiler barrier
    std::atomic_signal_fence(std::memory_order_seq_cst);
#endif
}

// Source - https://stackoverflow.com/a
// Posted by Christoph, modified by community. See post 'Timeline' for change history
// Retrieved 2026-01-20, License - CC BY-SA 2.5
#define IsAligned(POINTER, BYTE_COUNT) \
    (((uintptr_t)(const void *)(POINTER)) % (BYTE_COUNT) == 0)


// NOTE(marvin): The reason for two layers of macros is to allow the
// macro arguments to expand before token pasting.
#define NameConcat_(A, B) A##B
#define NameConcat(A, B) NameConcat_(A, B)

#define NameConcat3_(A, B, C) A##B##C
#define NameConcat3(A, B, C) NameConcat3_(A, B, C)

// Source - https://stackoverflow.com/a
// Posted by Artyer, modified by community. See post 'Timeline' for change history
// Retrieved 2026-01-16, License - CC BY-SA 4.0
#define VALUE_IFNOT_TEST(...) __VA_ARGS__
#define VALUE_IFNOT_TEST0(...) __VA_ARGS__
#define VALUE_IFNOT_TEST1(...)
#define VALUE_IFNOT(COND, ...) VALUE_IFNOT_TEST ## COND ( __VA_ARGS__ )

// Streamlines process of passing platform funcs to game module api.

// Helper macros
#define SKL_AS_FIELD(r, n, p) r (* n) p;
#ifndef SKL_GAME_MODULE
#define SKL_AS_HEADER_FUNC(r, n, p) r n p;
#define SKL_AS_CONSTRUCT_INSERT(r, n, p) ret.n = n;
#define SKL_AS_CONSTRUCT_FUNC(name, methods)\
    inline name construct##name() {\
        name ret{};\
        methods(SKL_AS_CONSTRUCT_INSERT)\
        return ret;\
    }
#else
#define SKL_AS_HEADER_FUNC(r, n, p);
#define SKL_AS_CONSTRUCT_INSERT(r, n, p);
#define SKL_AS_CONSTRUCT_FUNC(name, methods);
#endif

// Allows for funcs to be passed into the game module as a part of an api struct 
// while only being declared once
// @param name     the name of the api struct constructed by the macro, 
//                 if not in game module, use construct<name>() method to create instance of struct with declared methods.
// @param methods  defines which methods that will be in the api struct constructed by macro, 
//                 if not in game module, it also declares these functions.
#define DEFINE_GAME_MODULE_API(name, methods) \
    methods(SKL_AS_HEADER_FUNC) \
    struct name { \
        methods(SKL_AS_FIELD) \
    };\
    \
    SKL_AS_CONSTRUCT_FUNC(name, methods)
